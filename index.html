<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Spectrogram & Annotations</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="styles.css">
  <script>
    // Prevent context menu and certain keys
    (function () {
      window.addEventListener('contextmenu', function (e) { e.preventDefault(); }, { capture: true, passive: false });
      window.addEventListener('keydown', function (e) {
        if (e.key === 'ContextMenu' || (e.key === 'F10' && e.shiftKey) || e.keyCode === 93) { e.preventDefault(); e.stopPropagation(); }
      }, { capture: true, passive: false });
    })();
  </script>
  <style>
    /* Defensive: ensure species suggestions sit above overlays */
    .species-suggestions {
      z-index: 999999 !important;
      position: absolute;
      left: 0;
      right: 0;
      top: calc(100% + 6px);
      pointer-events: auto;
    }
  </style>
</head>
<body>
  <div id="controls">
    <input id="file" type="file" accept="audio/*" />

    <!-- Confirmation interceptor for file chooser -->
    <script>
    (function () {
      const file = document.getElementById('file');
      if (!file) return;
      const CONFIRM_MSG = 'Unsaved Metadata and Annotations will be lost. Continue?';
      let programmaticOpen = false;
      function openFilePicker() {
        programmaticOpen = true;
        try { file.click(); }
        finally { setTimeout(() => { programmaticOpen = false; }, 300); }
      }
      file.addEventListener('click', function (ev) {
        if (programmaticOpen) return;
        ev.preventDefault();
        const ok = window.confirm(CONFIRM_MSG);
        if (ok) openFilePicker();
      }, true);
      file.addEventListener('keydown', function (ev) {
        if (programmaticOpen) return;
        const k = ev.key;
        if (k === 'Enter' || k === ' ' || k === 'Spacebar') {
          ev.preventDefault();
          const ok = window.confirm(CONFIRM_MSG);
          if (ok) openFilePicker();
        }
      }, true);
      file.addEventListener('change', function () {
        try { window.__lastMetadata = null; } catch (e) {}
        const ov = document.getElementById('metaOverlay');
        if (ov) ov.remove();
      }, true);
    })();
    </script>

    
	<button id="go">Generate</button>
	<label for="cmap">Colormap</label>
    <select id="cmap">
      <option value="custom" selected>Custom</option>
      <option value="viridis">Viridis</option>
      <option value="magma">Magma</option>
      <option value="grayscale">Grayscale</option>
      <option value="jet">Jet</option>
      <option value="cividis">Cividis</option>
    </select>

    <label for="gain">Gain</label>
    <input id="gain" type="range" min="0.1" max="10" step="0.1" value="1" />
    <span id="gainVal">1.0×</span>

    <label for="xzoom">X zoom</label>
    <select id="xzoom">
      <option value="1">1x</option>
      <option value="2" selected>2x</option>
      <option value="3">3x</option>
      <option value="4">4x</option>
    </select>

    <label for="ymax">Y max (kHz)</label>
    <input id="ymax" type="number" min="0.1" step="0.1" style="width:100px" />

    
  </div>


	<!-- wait overlay (keep minimal markup in index.html) -->
	<div id="waitOverlay" role="status" aria-live="polite" aria-hidden="true">
	  <div class="panel" role="presentation">
		<div class="spinner" aria-hidden="true"></div>
		<div class="text">
		  <div class="title">Generating spectrogram</div>
		  <div class="msg">Processing image — this may take a few seconds.</div>
		  <div class="meta" id="waitOverlayMeta" style="display:none"><span id="waitOverlayETA"></span></div>
		</div>
	  </div>
	</div>


  <div id="viewportWrapper" role="region" aria-label="Spectrogram viewport">
    <canvas id="axisCanvas" width="70" height="420" role="img" aria-label="Frequency axis"></canvas>
    <div id="scrollArea">
      <canvas id="spectrogramCanvas" class="spectrogram" width="800" height="420" role="img" aria-label="Spectrogram"></canvas>
    </div>
  </div>

  <!-- Annotation toolbar: segmented toggle authoritative -->
  <div id="annotationControls" role="toolbar" aria-label="Annotation tools">
    
    <!-- Species search with label (in-toolbar) -->
    <div class="species-search" aria-label="Species search">
      <div class="label">Species</div>
      <div class="input-wrap">
        <input id="speciesKwInput" type="text" placeholder="Type key (2+ chars) to search species…" aria-label="Species key search" autocomplete="off" />
        <div id="speciesSuggest" class="species-suggestions" role="listbox" aria-label="Species suggestions" style="display:none"></div>
      </div>
      <div class="species-result-wrap empty" title="Selected species">
        <div id="speciesResult" class="species-result" aria-live="polite"></div>
        <button id="speciesClearBtn" class="clear-indicator" aria-label="Clear selection" title="Clear selection" style="display:none;">✕</button>
      </div>
      <input type="hidden" id="selectedSpeciesKey" value="" />
    </div>
	
	<!-- Segmented Create/Edit toggle (authoritative mode source) -->
    <div id="createEditToggle" class="seg-toggle" role="group" aria-label="Annotation mode" data-mode="create">
      <button type="button" id="toggleCreate" class="seg-option" data-mode="create" aria-pressed="true">Create</button>
      <button type="button" id="toggleEdit" class="seg-option" data-mode="edit" aria-pressed="false">Edit</button>
    </div>




	<!-- Single Delete -->
	<button id="annoDeleteBtn" type="button" title="Delete a Box in edit mode" aria-label="Delete annotation" class="icon-btn delete-btn">
	  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true" focusable="false">
		<path d="M3 6h18" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
		<path d="M8 6v12a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
		<path d="M10 6V4a2 2 0 0 1 2-2h0a2 2 0 0 1 2 2v2" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
	  </svg>
	</button>

	<!-- Multi-delete: dual-trash, wide and enabled -->
	<button id="multiDeleteBtn" type="button" title="Select row(s) & delete" aria-label="Multi-delete selected rows" class="multi-delete-btn wide" >
	  <svg class="multi-trash" viewBox="0 0 48 24" fill="none" aria-hidden="true" focusable="false" role="img">
		<g transform="translate(0,0)">
		  <path d="M3 6h18" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
		  <path d="M8 6v12a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
		  <path d="M10 6V4a2 2 0 0 1 2-2h0a2 2 0 0 1 2 2v2" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
		</g>
		<g transform="translate(24,0)">
		  <path d="M3 6h18" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
		  <path d="M8 6v12a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
		  <path d="M10 6V4a2 2 0 0 1 2-2h0a2 2 0 0 1 2 2v2" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
		</g>
	  </svg>
	</button>
		
	



    <!-- Metadata -->
    <button id="metaOpenBtn" type="button" title="Metadata" aria-label="Open metadata form" class="meta-open-btn" disabled>
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true">
		<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" stroke="currentColor" stroke-width="1.5" fill="none"></path>
		<path d="M14 2v6h6" stroke="currentColor" stroke-width="1.5" fill="none"></path>
	  </svg>
    </button>
	



	<!-- Download (Arrow) — uses existing toolbar styles -->
	<button id="saveAnnoBtn" type="button" title="Download" aria-label="Download" class="download-btn anno-btn">
	  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true" focusable="false">
		<path d="M12 3v12" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
		<path d="M8.5 10.5L12 14l3.5-3.5" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
		<path d="M5 20h14" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" opacity="0.9"/>
	  </svg>
	</button>


	
	
	
  </div>

  <script src="species-data.js"></script>

  <script src="spectrogram.js"></script>
  <script src="playback.js"></script>
  <script src="mouse.js"></script>

  <!-- Wire segmented toggle so scripts can read mode via #createEditToggle.dataset.mode and receive mode-change events -->
  <script>
  (function wireCreateEditToggle() {
    const wrap = document.getElementById('createEditToggle');
    if (!wrap) return;
    const btnCreate = document.getElementById('toggleCreate');
    const btnEdit = document.getElementById('toggleEdit');

    function setMode(mode, options = {}) {
      const createIs = mode === 'create';
      if (btnCreate) btnCreate.setAttribute('aria-pressed', createIs ? 'true' : 'false');
      if (btnEdit) btnEdit.setAttribute('aria-pressed', createIs ? 'false' : 'true');
      wrap.dataset.mode = mode;
      wrap.dispatchEvent(new CustomEvent('mode-change', { detail: { mode }, bubbles: true }));
      if (!options.silent) console.debug && console.debug('mode-change', mode);
    }

    btnCreate && btnCreate.addEventListener('click', () => setMode('create'));
    btnEdit && btnEdit.addEventListener('click', () => setMode('edit'));

    [btnCreate, btnEdit].forEach(b => {
      if (!b) return;
      b.addEventListener('keydown', (ev) => {
        if (ev.key === 'ArrowLeft') { setMode('create'); btnCreate && btnCreate.focus(); ev.preventDefault(); }
        if (ev.key === 'ArrowRight') { setMode('edit'); btnEdit && btnEdit.focus(); ev.preventDefault(); }
      });
    });

    if (!wrap.dataset.mode) setMode('create', { silent: true });
  })();
  </script>

	<script>
	(function wireCancelOnModeSwitch() {
	  const wrap = document.getElementById('createEditToggle');
	  if (!wrap) return;

	  wrap.addEventListener('mode-change', (ev) => {
		try {
		  const mode = ev && ev.detail && ev.detail.mode;
		  if (mode === 'edit') {
			// Broadcast event for modules to listen
			window.dispatchEvent(new CustomEvent('cancel-pending-create', { detail: { reason: 'mode-switch' }, bubbles: true }));
			// Also call direct API if available
			if (typeof window.__cancelPendingCreate === 'function') {
			  try { window.__cancelPendingCreate(); } catch (e) { console.warn('__cancelPendingCreate threw', e); }
			}
		  }
		} catch (err) { console.error('mode-change cancel handler', err); }
	  }, false);
	})();
	</script>




  <!-- create_annotations must load after toggle is wired -->
  <script src="create_annotations.js"></script>

  <script src="edit_annotations.js"></script>
  <script src="species_bulkedit.js"></script>
  <script src="display_label.js"></script>

  <!-- Patched species control (robust, uses bubbling so clicks on suggestions work) -->
  <script>
  (function () {
    const MIN_CHARS = 2;
    const DEBOUNCE_MS = 120;
    const MAX_RESULTS = 7;

    function norm(s) { return (s || '').toString().normalize().toLowerCase(); }
    function escapeHtml(s) { return s.replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'" :'&#39;'})[c] || '&amp;'); }

    function score(rec, q) {
      const nq = norm(q);
      const k = norm(rec.key || '');
      const c = norm(rec.common || '');
      let s = 0;
      if (k.startsWith(nq)) s += 120;
      else if (k.includes(nq)) s += 80;
      if (c.startsWith(nq)) s += 60;
      else if (c.includes(nq)) s += 30;
      s += Math.max(0, 10 - Math.min(9, (k.length||0) / 10));
      return s;
    }

    function highlight(orig, q) {
      if (!q) return escapeHtml(orig || '');
      const o = orig || '';
      const lower = norm(o);
      const nq = norm(q);
      const idx = lower.indexOf(nq);
      if (idx < 0) return escapeHtml(o);
      const before = o.slice(0, idx), match = o.slice(idx, idx + q.length), after = o.slice(idx + q.length);
      return escapeHtml(before) + '<span class="species-mark">' + escapeHtml(match) + '</span>' + escapeHtml(after);
    }

    const input = () => document.getElementById('speciesKwInput');
    const suggest = () => document.getElementById('speciesSuggest');
    const result = () => document.getElementById('speciesResult');
    const clearBtn = () => document.getElementById('speciesClearBtn');
    const resultWrap = () => document.querySelector('.species-result-wrap');
    const hidden = () => document.getElementById('selectedSpeciesKey');

    function whenReady(cb) {
      if (document.readyState === 'interactive' || document.readyState === 'complete') setTimeout(cb, 0);
      else window.addEventListener('DOMContentLoaded', () => setTimeout(cb, 0));
    }

    whenReady(() => {
      const MAX_TRIES = 40;
      let tries = 0;
      const t = setInterval(() => {
        tries++;
        if (Array.isArray(window.__speciesRecords)) {
          clearInterval(t);
          wireSpeciesControl(window.__speciesRecords);
        } else if (tries >= MAX_TRIES) {
          clearInterval(t);
          console.warn('species-data.js not found or window.__speciesRecords not defined; control will wire empty.');
          wireSpeciesControl([]);
        }
      }, 80);
    });

    function wireSpeciesControl(records) {
      const recs = Array.isArray(records) ? records : (window.__speciesRecords || []);
      window.__speciesRecords = recs;

      const elInput = input();
      const elSuggest = suggest();
      const elResult = result();
      const elClear = clearBtn();
      const elResultWrap = resultWrap();
      const elHidden = hidden();

      if (!elInput || !elSuggest || !elResult || !elHidden || !elResultWrap) {
        setTimeout(() => wireSpeciesControl(recs), 120);
        return;
      }

      elHidden.value = '';
      elResult.textContent = '';
      elClear.style.display = 'none';
      elResultWrap.classList.add('empty');

      let debounceTimer = null;
      let lastQuery = '';
      let activeIdx = -1;

      function close() { elSuggest.innerHTML = ''; elSuggest.style.display = 'none'; activeIdx = -1; }

      function render(q) {
        lastQuery = q;
        activeIdx = -1;
        elSuggest.innerHTML = '';
        elSuggest.style.display = 'none';
        if (!q || q.length < MIN_CHARS) { return; }
        const cand = recs.map(r => ({ r, s: score(r, q) })).filter(x => x.s > 0).sort((a,b) => b.s - a.s).slice(0, MAX_RESULTS);
        if (!cand.length) return;
        cand.forEach((cobj, i) => {
          const r = cobj.r;
          const div = document.createElement('div');
          div.className = 'item';
          div.style.display = 'flex';
          div.style.gap = '8px';
          div.style.padding = '8px 10px';
          div.style.cursor = 'pointer';
          div.dataset.idx = i;
          div.innerHTML = '<div class="common">' + highlight(r.common||'', q) + '</div>';
          div.addEventListener('click', (ev) => { ev.preventDefault(); pick(i); });
          elSuggest.appendChild(div);
        });
        elSuggest.style.display = 'block';
      }

      function applySelection(chosen) {
        elHidden.value = chosen.key || '';
        elResult.textContent = chosen.common || '';
        elClear.style.display = 'inline-flex';
        elResultWrap.classList.remove('empty');
        elHidden.dispatchEvent(new Event('input', { bubbles: true }));
        const wrapper = elResultWrap.closest('.species-search') || document.querySelector('.species-search');
        if (wrapper) wrapper.dispatchEvent(new CustomEvent('species-select', { detail: { key: chosen.key, common: chosen.common, scientific: chosen.scientific }, bubbles: true }));
      }

      function clearSelection() {
        const prev = elHidden.value || null;
        elHidden.value = '';
        elResult.textContent = '';
        elClear.style.display = 'none';
        elResultWrap.classList.add('empty');
        elHidden.dispatchEvent(new Event('input', { bubbles: true }));
        const wrapper = elResultWrap.closest('.species-search') || document.querySelector('.species-search');
        if (wrapper) wrapper.dispatchEvent(new CustomEvent('species-select-cleared', { detail: { previousKey: prev }, bubbles: true }));
      }

      function pick(idx) {
        const cand = recs.map(r => ({ r, s: score(r, lastQuery) })).filter(x => x.s > 0).sort((a,b) => b.s - a.s).slice(0, MAX_RESULTS);
        const chosen = (cand[idx] && cand[idx].r) || null;
        if (!chosen) return;
        applySelection(chosen);
        elInput.value = '';
        close();
        elInput.focus();
      }

      function acceptTop() {
        const q = elInput.value.trim();
        if (!q) return;
        const best = recs.map(r => ({ r, s: score(r, q) })).filter(x => x.s > 0).sort((a,b)=>b.s-a.s)[0];
        if (!best) return;
        applySelection(best.r);
        elInput.value = '';
        close();
      }

      function updateActive(items) {
        items.forEach((it, i) => {
          it.style.background = (i === activeIdx) ? '#eef6ff' : '';
          if (i === activeIdx) it.scrollIntoView({ block: 'nearest' });
        });
      }

      elResultWrap.addEventListener('mouseenter', () => { if (elHidden.value) elClear.style.display = 'inline-flex'; });
      elResultWrap.addEventListener('mouseleave', () => { if (elHidden.value) elClear.style.display = 'none'; });

      elClear.addEventListener('click', (e) => { e.preventDefault(); clearSelection(); elInput.focus(); });

      elInput.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && elInput.value.trim() === '') {
          e.preventDefault();
          clearSelection();
        }
      });

      elInput.addEventListener('input', () => {
        const q = elInput.value.trim();
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => render(q), DEBOUNCE_MS);
      });

      elInput.addEventListener('keydown', (e) => {
        const items = elSuggest.querySelectorAll('.item');
        if (elSuggest.style.display === 'block' && items.length) {
          if (e.key === 'ArrowDown') { e.preventDefault(); activeIdx = Math.min(items.length - 1, activeIdx + 1); updateActive(items); return; }
          if (e.key === 'ArrowUp')   { e.preventDefault(); activeIdx = Math.max(0, activeIdx - 1); updateActive(items); return; }
          if (e.key === 'Enter') {
            if (activeIdx >= 0 && activeIdx < items.length) { e.preventDefault(); pick(activeIdx); return; }
            e.preventDefault(); acceptTop(); return;
          }
          if (e.key === 'Escape') { close(); return; }
        } else {
          if (e.key === 'Enter') { e.preventDefault(); acceptTop(); return; }
        }
      });

      // OUTSIDE CLICK: use bubble phase so clicks on suggestion items occur first
      document.addEventListener('click', (ev) => {
        try {
          const path = (ev.composedPath && ev.composedPath()) || ev.path || [];
          const inside = path.some(node => {
            try { return node && node.classList && node.classList.contains && node.classList.contains('species-search'); } catch (e) { return false; }
          });
          if (!inside) close();
        } catch (err) {
          // fallback conservative check
          try {
            if (!elInput.closest('.species-search') && !document.querySelector('.species-search').contains(ev.target)) close();
          } catch (e) { /* ignore */ }
        }
      }, false);

      // ensure suggestions are above overlays (defensive if CSS not present)
      elSuggest.style.zIndex = elSuggest.style.zIndex || '999999';
    }
  })();
  </script>

  <script>
  (function () {
    const FILE_ID = 'file';
    const META_BTN_ID = 'metaOpenBtn';

    function findFile() { return document.getElementById(FILE_ID); }
    function findMetaBtn() { return document.getElementById(META_BTN_ID); }

    function updateMetaBtnState() {
      const btn = findMetaBtn();
      const file = findFile();
      if (!btn) return;
      try {
        const hasFile = file && file.files && file.files.length > 0;
        btn.disabled = !hasFile;
      } catch (e) {
        btn.disabled = true;
      }
    }

    function wireMetaButtonOnce() {
      const btn = findMetaBtn();
      if (!btn) return;
      if (btn.__indexMetaWired) return;
      btn.addEventListener('click', function (ev) {
        ev.stopPropagation();
        if (btn.disabled) return;
        if (typeof window.__openMetadataModal === 'function') {
          try { window.__openMetadataModal(); } catch (err) { console.error('Open metadata failed', err); }
        } else {
          console.warn('Metadata API not available: window.__openMetadataModal');
        }
      }, true);
      btn.__indexMetaWired = true;
    }

    function observeFileInput() {
      const file = findFile();
      if (!file) {
        setTimeout(observeFileInput, 120);
        return;
      }
      updateMetaBtnState();
      file.addEventListener('change', () => {
        try { window.__lastMetadata = null; } catch (e) {}
        const ov = document.getElementById('metaOverlay');
        if (ov) ov.remove();
        updateMetaBtnState();
      }, true);
      const mo = new MutationObserver(() => updateMetaBtnState());
      mo.observe(file, { attributes: true, attributeFilter: ['value'] });
    }

    function init() {
      wireMetaButtonOnce();
      observeFileInput();
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else init();

    (function waitForBtn(timeout = 8000) {
      const btn = findMetaBtn();
      if (!btn) {
        setTimeout(() => waitForBtn(Math.max(1000, timeout - 1000)), 400);
      } else {
        wireMetaButtonOnce();
        updateMetaBtnState();
      }
    })();
  })();
  </script>

  <script src="metadata.js"></script>
  <script src="save_annotations.js"></script>
</body>
</html>
